# Reflection
Steven Setiawan - 2306152260

> What are the key differences between unary, server streaming, and bi-directional streaming RPC (Remote Procedure Call) methods, and in what scenarios would each be most suitable?

- **Unary RPC** melibatkan satu permintaan dan satu respons, ideal untuk operasi query dan response sederhana seperti autentikasi, validasi data, atau manipulasi data di database. Metode ini sering digunakan sebagai alternatif REST API untuk komunikasi antar server.

- **Server streaming RPC** memungkinkan klien mengirim satu permintaan tetapi menerima aliran data berkelanjutan dari server. Metode ini cocok untuk pengiriman data besar yang dipecah menjadi potongan kecil, pemrosesan asinkron dengan hasil parsial, atau aplikasi yang membutuhkan aliran data secara real-time seperti notifikasi.

- **Bi-directional streaming RPC** memungkinkan kedua pihak (klien dan server) mengirim aliran pesan secara bersamaan dan independen. Metode ini sangat sesuai untuk aplikasi interaktif real-time seperti chat, game multiplayer, atau situasi lain yang membutuhkan komunikasi dua arah asinkronus yang cepat dan responsif.

> What are the potential security considerations involved in implementing a gRPC service in Rust, particularly regarding authentication, authorization, and data encryption?

- **Autentikasi**, yaitu memastikan identitas klien terverifikasi sangat penting dalam gRPC. Rust mendukung berbagai mekanisme autentikasi seperti JWT tokenm OAuth2, API keys, atau mutual TLS (mTLS). Hal ini sangat penting untuk diperhatikan karena kita perlu memilih mekanisme yang sesuai dengan kebutuhan aplikasi dan memvalidasi identitas klien sebelum mengizinkan akses ke data sensitif.

- **Otorisasi**, di mana setelah terautentikasi, layanan perlu memverifikasi apakah klien memiliki izin yang tepat untuk mengakses resource atau melakukan operasi tertentu. Implementasi mekanisme seperti RBAC dapat membantu membatasi akses berdasarkan peran atau atribut pengguna. Rust memungkinkan penerapan kebijakan kontrol akses yang terperinci untuk mencegah akses tidak sah.

- **Enkripsi data** digunakan untuk mengamankan data dalam komunikasi gRPC. Implementasi TLS/SSL adalah standar untuk mengenkripsi komunikasi antara klien dan server. Rust menawarkan keunggulan tambahan melalui pengelolaan memori yang aman dan sistem tipe yang ketat, tetapi kita selaku developer tetap perlu menerapkan validasi input tambahan yang ketat, logging audit yang memadai, dan perlindungan terhadap serangan seperti DDoS atau MITM untuk memastikan keamanan layanan gRPC. 

> What are the potential challenges or issues that may arise when handling bidirectional streaming in Rust gRPC, especially in scenarios like chat applications?

Beberapa tantangan yang mungkin muncul saat menangani bidirectional streaming di Rust gRPC, terutama dalam skenario seperti aplikasi chat, meliputi:

- **Pengelolaan konkurensi dan sinkronisasi** merupakan salah satu tantangan utama dalam mengelola aliran pesan yang masuk dan keluar secara bersamaan. Rust sendiri menawarkan fitur konkurensi yang kuat, tetapi mengimplementasikan sinkronisasi yang tepat antara thread request dan response memerlukan perhatian khusus, terutama ketika melibatkan banyak klien yang terhubung secara simultan.

- **Penanganan kegagalan dan pemulihan** merupakan salah satu tantangan penting dalam aplikasi streaming seperti chat. Implementasi mekanisme penanganan kesalahan yang tepat diperlukan untuk memastikan stream ditutup dan dibersihkan dengan benar jika terjadi kesalahan. Menerapkan logika retry, timeout, dan recovery sangat krusial agar layanan dapat berjalan dengan baik meskipun dalam  kondisi jaringan yang tidak stabil.

- **Manajemen sumber daya dan backpressure** sangat penting untuk menghindari kebocoran memori atau kehabisan resources, terutama ketika klien mengirim pesan lebih cepat daripada kemampuan server untuk memprosesnya. Tanpa pengelolaan sumber daya yang tepat, aplikasi dapat mengalami penurunan kinerja atau bahkan kegagalan sistem saat menangani volume pesan yang besar dalam aliran dua arah yang simultan.

> What are the advantages and disadvantages of using the tokio_stream::wrappers::ReceiverStream for streaming responses in Rust gRPC services?

Penggunaan `tokio_stream::wrappers::ReceiverStream` untuk respons streaming dalam layanan gRPC Rust menawarkan beberapa keuntungan signifikan seperti integrasi yang mudah dengan ekosistem asinkronus Tokio, manajemen backpressure bawaan melalui stream berkapasitas terbatas, dan abstraksi tingkat tinggi yang menyederhanakan pengelolaan stream. Namun, pendekatan ini juga memiliki beberapa keterbatasan yang perlu dipertimbangkan, seperti potensi overhead kinerja dari saluran stream tambahan, risiko kebocoran memori, dan kompleksitas tambahan bagi developer yang belum familiar dengan pemrograman asinkronus di Rust. Dengan demikian, sangat penting bagi kita untuk menyeimbangkan kebutuhan kinerja, keandalan, dan kemudahan pengembangan saat memilih apakah akan menggunakan `ReceiverStream` dalam implementasi gRPC.

> In what ways could the Rust gRPC code be structured to facilitate code reuse and modularity, promoting maintainability and extensibility over time?

Untuk memfasilitasi _code reuse_ dan modularitas dalam gRPC Rust, struktur kode dapat diorganisir dengan memisahkan komponen service, implementasi, dan logika bisnis menjadi modul-modul terpisah. Best practice yang dapat kita lakukan meliputi penerapan dependency injection untuk mengurangi ketergantungan langsung antar komponen, memungkinkan pengujian yang lebih mudah. Abstraksi yang tepat seperti trait dan interface dapat digunakan untuk mendefinisikan _contract_ antar modul, sementara kode yang digunakan bersama dapat diekstrak ke dalam _crate_ terpisah yang dapat digunakan kembali di seluruh layanan. Implementasi penanganan kesalahan yang konsisten dengan tipe `Result` atau `Option` dapat membantu meningkatkan keterbacaan kode. Secara keseluruhan, pemisahan ini tidak hanya mengurangi duplikasi dan meningkatkan keterbacaan, tetapi juga memfasilitas pengembangan secara paralel, memungkinkan kita sebagai suatu tim developer untuk bekerja pada bagian yang berbeda dari aplikasi tanpa konflik satu sama lain, sekaligus menjadikan sistem lebih mudah diupgrade tanpa memerlukan perubahan signifikan pada kode yang ada.

> In the MyPaymentService implementation, what additional steps might be necessary to handle more complex payment processing logic?

Dalam implementasi `MyPaymentService`, beberapa langkah tambahan diperlukan untuk menangani logika pemrosesan pembayaran yang lebih kompleks. Langkah-langkah ini mencakup validasi input yang komprehensif untuk memverifikasi pengguna, jumlah pembayaran, dan detail transaksi lainnya, serta integrasi dengan gateway pembayaran pihak ketiga untuk memproses transaksi secara aman. Selain itu, kita juga perlu mengimplementasikan mekanisme transaksi dan rollback untuk menjaga integritas data jika terjadi kegagalan, serta sistem logging audit yang mendetail. Penambahan logika bisnis yang lebih _advance_ juga diperlukan, seperti deteksi _fraud_ secara real-time, pengelolaan batas pengeluaran, dan sistem notifikasi multi-stream untuk memberi informasi status transaksi kepada pengguna melalui layanan email atau SMS. Penerapan strategi _error handling_ yang baik dengan mekanisme _retry_ dan _fail over_ juga penting untuk memastikan keandalan layanan pembayaran, bahkan dalam kondisi jaringan yang tidak stabil.

> What impact does the adoption of gRPC as a communication protocol have on the overall architecture and design of distributed systems, particularly in terms of interoperability with other technologies and platforms?

Adopsi gRPC sebagai protokol komunikasi memberikan dampak signifikan pada arsitektur dan desain sistem terdistribusi. gRPC menawarkan interoperabilitas tinggi antar layanan yang ditulis dalam bahasa pemrograman berbeda melalui penggunaan Protocol Buffers sebagai bahasa definisi antarmuka, memungkinkan komunikasi yang mulus antara layanan yang dikembangkan dengan teknologi berbeda. Kinerja sistem secara keseluruhan meningkat berkat penggunaan HTTP/2 yang mendukung multiplexing, kompresi header, dan streaming dua arah, sehingga menghasilkan komunikasi yang lebih cepat dan efisien dibandingkan dengan REST tradisional. Namun, adopsi gRPC juga memperkenalkan kompleksitas tambahan dalam pengujian serta tantangan interoperabilitas dengan aplikasi web tradisional yang mungkin memerlukan gateway API untuk menerjemahkan antara gRPC dan format lain seperti JSON. Pendekatan berbasis _contract_ melalui file Proto sendiri mendorong pengembangan paralel dan konsistensi antarmuka sembari menyediakan fitur _code generation_ otomatis yang mengurangi _boilerplate_ dan meningkatkan produktivitas pengembang.

> What are the advantages and disadvantages of using HTTP/2, the underlying protocol for gRPC, compared to HTTP/1.1 or HTTP/1.1 with WebSocket for REST APIs?

HTTP/2, protokol dasar untuk gRPC, menawarkan beberapa keunggulan dibandingkan dengan HTTP/1.1 atau HTTP/1.1 dengan WebSocket untuk REST API. Keunggulan utamanya adalah multiplexing yang memungkinkan beberapa request dan response dikirim secara paralel melalui satu koneksi, kompresi header yang mengurangi overhead jaringan, dan sistem prioritas stream yang memungkinkan resources penting untuk diproses lebih dahulu. Namun, HTTP/2 juga memiliki kekurangan, seperti kompleksitas implementasi yang lebih tinggi, kompatibilitas terbatas dengan beberapa server dan klien lama, serta konsumsi resources server yang potensial lebih besar. Sementara WebSocket menawarkan komunikasi full-duplex yang cocok untuk aplikasi real-time dan interaktif, WebSocket tidak memiliki fitur multiplexing bawaan HTTP/2 dan kerangka kerja _contract_ terstruktur seperti yang ditawarkan oleh gRPC dengan Protocol Buffers, meskipun WebSocket mungkin lebih cocok untuk beberapa aplikasi berbasis browser karena dukungan browser yang lebih luas.

> How does the request-response model of REST APIs contrast with the bidirectional streaming capabilities of gRPC in terms of real-time communication and responsiveness?

Model request-response REST API berbeda secara signifikan dengan kemampuan streaming dua arah gRPC dalam hal komunikasi real-time. Dalam REST API, klien mengirimkan permintaan dan harus menunggu respons server sebelum melanjutkan interaksi berikutnya, menciptakan pola komunikasi sinkron yang kaku. Pendekatan ini efektif untuk operasi CRUD sederhana, tetapi memiliki keterbatasan dalam skenario real-time, di mana klien harus melakukan polling berulang untuk mendapatkan pembaruan terbaru. Sebaliknya, gRPC dengan kemampuan streaming dua arahnya memungkinkan komunikasi asinkron berkelanjutan antara klien dan server, di mana kedua belah pihak dapat mengirim stream pesan secara bersamaan tanpa harus menunggu permintaan baru. Kemampuan ini sangat meningkatkan responsitivitas dalam aplikasi seperti obrolan, permainan multiplayer, atau pemantauan real-time dengan menghilangkan overhead polling dan mengurangi latensi. Meskipun REST dapat mengadopsi WebSocket untuk fungsionalitas serupa, gRPC menawarkan solusi yang lebih terintegrasi dengan dukungan streaming native dan penggunaan bandwidth yang lebih efisien melalui Protocol Buffers.

> What are the implications of the schema-based approach of gRPC, using Protocol Buffers, compared to the more flexible, schema-less nature of JSON in REST API payloads?

Pendekatan berbasis skema gRPC dengan Protocol Buffers berbeda signifikan dari sifat JSON yang lebih fleksibel dalam REST API. Protocol Buffers menawarkan validasi tipe yang ketat, payload yang jauh lebih kecil, dan serialisasi/deserialisasi yang lebih cepat, sementara juga menyediakan _contract_ eksplisit yang mengurangi kesalahan runtime dan meningkatkan keamanan dalam proses development. Semantara itu, JSON lebih mudah di-debug karena format teks yang dapat dibaca manusia, lebih fleksibel untuk evolusi API tanpa memerlukan kompilasi ulang, dan memiliki dukungan yang lebih luas di berbagai platform dan bahasa, meksipun dengan mengorbankan ukuran payload yang lebih besar dan rentan terhadap kesalahan runtime karena kurangnya validasi tipe. Pilihan antara keduanya bergantung pada prioritas proyek, di mana gRPC lebih cocok untuk komunikasi antar-layanan internal sedangkan REST/JSON lebih sesuai untuk API publik yang memerlukan fleksibilitas dan aksesibilitas yang lebih luas.